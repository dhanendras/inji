function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useEffect, useRef } from 'react';
import { Animated, StyleSheet, Text, View } from 'react-native';
import Caret from './Caret';
import { ANIMATION_DURATION } from './constants';
import { POPOVER_BACKGROUND_COLOR, BORDER_RADIUS, POPOVER_FONT_COLOR, POPOVER_FONT_SIZE, POPOVER_PADDING, POPOVER_WIDTH } from './style-guide';
const Popover = /*#__PURE__*/React.forwardRef(function Popover({
  animated = true,
  animationType = 'timing',
  backgroundColor,
  caret: withCaret = true,
  caretPosition = 'center',
  children,
  forceInitialAnimation = false,
  numberOfLines,
  visible = true,
  position = 'bottom',
  style,
  ...extraProps
}, ref) {
  const isContentString = typeof children === 'string';
  const isHorizontalLayout = position === 'left' || position === 'right';
  const prevVisible = useRef(visible);
  const opacity = useRef(new Animated.Value(visible ? forceInitialAnimation ? 0 : 1 : forceInitialAnimation ? 1 : 0)).current;
  useEffect(() => {
    let animation;

    if (animated) {
      var _animation;

      if (visible && (!prevVisible.current || forceInitialAnimation)) {
        animation = Animated[animationType](opacity, {
          toValue: 1,
          duration: ANIMATION_DURATION,
          useNativeDriver: true
        });
      } else if (!visible && (prevVisible.current || forceInitialAnimation)) {
        animation = Animated[animationType](opacity, {
          toValue: 0,
          duration: ANIMATION_DURATION,
          useNativeDriver: true
        });
      }

      (_animation = animation) === null || _animation === void 0 ? void 0 : _animation.start();
    }

    prevVisible.current = visible;
    return () => {
      var _animation2;

      return (_animation2 = animation) === null || _animation2 === void 0 ? void 0 : _animation2.stop();
    };
  }, [visible] // eslint-disable-line react-hooks/exhaustive-deps
  );
  const caret = /*#__PURE__*/React.createElement(Caret, {
    align: caretPosition,
    position: position,
    backgroundColor: backgroundColor,
    style: styles.caret
  });
  let animationTranslation;

  if (isHorizontalLayout) {
    animationTranslation = {
      translateX: opacity.interpolate({
        inputRange: [0, 1],
        outputRange: position === 'left' ? [5, 0] : [-5, 0]
      })
    };
  } else {
    animationTranslation = {
      translateY: opacity.interpolate({
        inputRange: [0, 1],
        outputRange: position === 'top' ? [5, 0] : [-5, 0]
      })
    };
  }

  return /*#__PURE__*/React.createElement(View, _extends({
    ref: ref,
    style: [styles.container, style],
    pointerEvents: visible ? 'auto' : 'none'
  }, extraProps), /*#__PURE__*/React.createElement(Animated.View, {
    style: [{
      opacity,
      transform: [animationTranslation]
    }, isHorizontalLayout && styles.containerHorizontal]
  }, withCaret && (position === 'bottom' || position === 'right') && caret, /*#__PURE__*/React.createElement(View, {
    style: [styles.content, isContentString && styles.contentTextOnly, !!backgroundColor && {
      backgroundColor
    }]
  }, isContentString ? /*#__PURE__*/React.createElement(Text, {
    numberOfLines: numberOfLines,
    style: styles.contentText
  }, children) : children), withCaret && (position === 'top' || position === 'left') && caret));
});
const styles = StyleSheet.create({
  container: {
    width: POPOVER_WIDTH,
    overflow: 'hidden'
  },
  containerHorizontal: {
    flexDirection: 'row'
  },
  content: {
    flex: 1,
    zIndex: 1,
    backgroundColor: POPOVER_BACKGROUND_COLOR,
    borderRadius: BORDER_RADIUS * 2,
    overflow: 'hidden'
  },
  contentTextOnly: {
    padding: POPOVER_PADDING
  },
  contentText: {
    color: POPOVER_FONT_COLOR,
    fontSize: POPOVER_FONT_SIZE,
    fontWeight: 'bold',
    textAlign: 'center'
  },
  caret: {
    zIndex: 0
  }
});
export default Popover;
//# sourceMappingURL=Popover.js.map