"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var asn = _interopRequireWildcard(require("asn1js"));

var _jsBase = require("js-base64");

var _buffer = require("buffer");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);

  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }

  return buf;
}

const buffer2base64uri = buff => buff.toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');

const addOptions = (jwk, opts) => {
  if (opts.use && !['sig', 'enc'].includes(opts.use)) {
    throw Error('"use" must be either "sig" or "enc"');
  }

  return { ...jwk,
    ...opts
  };
};

const pem2jwk = (pem, opts) => {
  let kind = undefined; // fetch the part of the PEM string between header and footer

  const lines = pem.trim().split('\n');
  const pemHeader = lines[0];
  const pemFooter = lines[lines.length - 1];

  if (pemHeader === '-----BEGIN RSA PRIVATE KEY-----' && pemFooter === '-----END RSA PRIVATE KEY-----') {
    kind = 'private';
  } else if (pemHeader === '-----BEGIN RSA PUBLIC KEY-----' && pemFooter === '-----END RSA PUBLIC KEY-----') {
    kind = 'public';
  } else {
    throw Error(`Headers not supported: ${pemHeader}\n ${pemFooter}`);
  }

  const pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length); // base64 decode the string to get the binary data

  const binaryDerString = _jsBase.Base64.atob(pemContents); // convert from a binary string to an ArrayBuffer


  const binaryDer = str2ab(binaryDerString);
  const sequence = asn.fromBER(binaryDer);
  const fieldNames = {
    private: ['n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi'],
    public: ['n', 'e']
  };
  const fieldValues = kind === 'private' ? sequence.result.valueBlock.value.slice(1) : sequence.result.valueBlock.value;
  const fields = fieldValues.map(x => x.valueBlock.valueHex).map((val, i) => i === 1 || val.byteLength % 2 === 0 ? val : val.slice(1)).map(x => _buffer.Buffer.from(x)).map(b => buffer2base64uri(b)).map((b64, i) => ({
    [fieldNames[kind][i]]: b64
  }));
  const jwk = Object.assign({}, ...fields, {
    kty: 'RSA'
  });
  const result = opts ? addOptions(jwk, opts) : jwk;
  return result;
};

var _default = pem2jwk;
exports.default = _default;